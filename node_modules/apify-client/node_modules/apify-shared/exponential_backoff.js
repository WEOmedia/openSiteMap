'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retryWithExpBackoff = exports.RetryableError = undefined;

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

var _utilities = require('./utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class RetryableError extends Error {
    constructor(originalError, ...args) {
        super(...args);
        this.error = originalError;
    }
}

exports.RetryableError = RetryableError;
const retryWithExpBackoff = exports.retryWithExpBackoff = async (params = {}) => {
    const { func, expBackoffMillis, expBackoffMaxRepeats } = params;
    if (typeof func !== 'function') {
        throw new Error('Parameter "func" should be a function.');
    }
    if (typeof expBackoffMillis !== 'number') {
        throw new Error('Parameter "expBackoffMillis" should be a number.');
    }
    if (typeof expBackoffMaxRepeats !== 'number') {
        throw new Error('Parameter "expBackoffMaxRepeats" should be a number.');
    }

    for (let i = 0;; i++) {
        let error;

        try {
            return await func();
        } catch (e) {
            error = e;
        }

        if (!(error instanceof RetryableError)) {
            throw error;
        }

        if (i >= expBackoffMaxRepeats - 1) {
            throw error.error;
        }

        const waitMillis = expBackoffMillis * 2 ** i;
        const randomizedWaitMillis = _underscore2.default.random(waitMillis, waitMillis * 2);

        if (i === Math.round(expBackoffMaxRepeats / 2)) {
            _log2.default.warning(`Retry failed ${i} times and will be repeated in ${randomizedWaitMillis}ms`, {
                originalError: error.error.message,
                errorDetails: error.error.details
            });
        }

        await (0, _utilities.delayPromise)(randomizedWaitMillis);
    }
};