'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SIGNED_URL_UPLOAD_MIN_BYTESIZE = exports.BASE_PATH = undefined;

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Key-value Stores
 * @memberOf ApifyClient
 * @description
 * ### Basic usage
 * ```javascript
 * const ApifyClient = require('apify-client');
 *
 * const apifyClient = new ApifyClient({
 *        userId: 'RWnGtczasdwP63Mak',
 *        token: 'f5J7XsdaKDyRywwuGGo9',
 * });
 * const keyValueStores = apifyClient.keyValueStores;
 *
 * const store = await keyValueStores.getOrCreateStore({ storeName: 'my-store' });
 * apifyClient.setOptions({ storeId: store.id });
 * await keyValueStores.putRecord({
 *      key: 'foo',
 *      body: 'bar',
 *      contentType: 'text/plain; charset=utf-8',
 * });
 * const record = await keyValueStores.getRecord({ key: 'foo' });
 * const keys = await keyValueStores.getRecordsKeys();
 * await keyValueStores.deleteRecord({ key: 'foo' });
 * ```
 *
 * Every method can be used as either promise or with callback. If your Node version supports await/async then you can await promise result.
 * ```javascript
 * // Awaited promise
 * try {
 *      const record = await keyValueStores.getRecord({ key: 'foo' });
 *      // Do something record ...
 * } catch (err) {
 *      // Do something with error ...
 * }
 *
 * // Promise
 * keyValueStores.getRecord({ key: 'foo' })
 * .then((RECORD) => {
 *      // Do something record ...
 * })
 * .catch((err) => {
 *      // Do something with error ...
 * });
 *
 * // Callback
 * keyValueStores.getRecord({ key: 'foo' }, (err, record) => {
 *      // Do something with error or record ...
 * });
 * ```
 * @namespace keyValueStores
 */

const BASE_PATH = exports.BASE_PATH = '/v2/key-value-stores';
const SIGNED_URL_UPLOAD_MIN_BYTESIZE = exports.SIGNED_URL_UPLOAD_MIN_BYTESIZE = 1024 * 256;

exports.default = {
    /**
     * Creates store of given name and returns it's object. If store with given name already exists then returns it's object.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {String} options.storeName - Custom unique name to easily identify the store in the future.
     * @param callback
     * @returns {KeyValueStore}
     */
    getOrCreateStore: (requestPromise, options) => {
        const { baseUrl, token, storeName } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(storeName, 'storeName', 'String');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}`,
            json: true,
            method: 'POST',
            qs: { name: storeName, token }
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Gets list of key-value stores.
     *
     * By default, the objects are sorted by the createdAt field in ascending order,
     * therefore you can use pagination to incrementally fetch all stores while new ones are still being created.
     * To sort them in descending order, use desc: `true` parameter.
     * The endpoint supports pagination using limit and offset parameters and it will not return more than 1000 array elements.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {Number} [options.offset=0] - Number of array elements that should be skipped at the start.
     * @param {Number} [options.limit=1000] - Maximum number of array elements to return.
     * @param {Boolean} [options.desc] - If `true` then the objects are sorted by the startedAt field in descending order.
     * @param {Boolean} [options.unnamed] - If `true` then also unnamed stores will be returned. By default only named stores are returned.
     * @param callback
     * @returns {PaginationList}
     */
    listStores: (requestPromise, options) => {
        const { baseUrl, token, offset, limit, desc, unnamed } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(limit, 'limit', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(offset, 'offset', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(desc, 'desc', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(unnamed, 'unnamed', 'Maybe Boolean');

        const query = { token };

        if (limit) query.limit = limit;
        if (offset) query.offset = offset;
        if (desc) query.desc = 1;
        if (unnamed) query.unnamed = 1;

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}`,
            json: true,
            method: 'GET',
            qs: query
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Gets key-value store.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     * @returns {KeyValueStore}
     */
    getStore: (requestPromise, options) => {
        const { baseUrl, storeId, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'Maybe String');

        const query = {};
        if (token) query.token = token;

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${storeId}`,
            json: true,
            method: 'GET',
            qs: query
        }).then(_utils.pluckData).then(_utils.parseDateFields).catch(_utils.catchNotFoundOrThrow);
    },

    /**
     * Updates key-value store.
     *
     * @memberof ApifyClient.stores
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {String} options.storeId - Unique store ID
     * @param {Object} options.store
     * @param callback
     * @returns {KeyValueStore}
     */
    updateStore: (requestPromise, options) => {
        const { baseUrl, token, storeId, store } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(store, 'store', 'Object');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${storeId}`,
            json: true,
            method: 'PUT',
            qs: { token },
            body: _underscore2.default.omit(store, 'id')
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Deletes key-value store.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     * @returns {*}
     */
    deleteStore: (requestPromise, options) => {
        const { baseUrl, storeId, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${storeId}`,
            json: true,
            method: 'DELETE',
            qs: { token }
        });
    },

    /**
     * Gets value stored in the key-value store under the given key.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} options.key - Key of the record
     * @param {Boolean} [options.disableBodyParser] - It true, it doesn't parse record's body based on content type.
     * @param {Boolean} [options.disableRedirect] - API by default redirects user to signed record url for faster download.
                                                    If disableRedirect=1 is set then API returns the record value directly.
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     * @returns {KeyValueStoreRecord}
     */
    getRecord: (requestPromise, options) => {
        const { baseUrl, storeId, key, disableBodyParser, disableRedirect, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(key, 'key', 'String');
        (0, _utils.checkParamOrThrow)(disableBodyParser, 'disableBodyParser', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(disableRedirect, 'disableRedirect', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(token, 'token', 'Maybe String');

        const requestOpts = {
            url: `${baseUrl}${BASE_PATH}/${storeId}/records/${key}`,
            method: 'GET',
            json: false,
            qs: {},
            gzip: true,
            resolveWithFullResponse: true,
            encoding: null
        };

        if (disableRedirect) requestOpts.qs.disableRedirect = 1;
        if (token) requestOpts.qs.token = token;

        const parseResponse = response => {
            const responseBody = response.body;
            const contentType = response.headers['content-type'];
            const body = disableBodyParser ? responseBody : (0, _utils.parseBody)(responseBody, contentType);

            return {
                contentType,
                body
            };
        };

        return requestPromise(requestOpts).then(parseResponse).catch(_utils.catchNotFoundOrThrow);
    },

    /**
     * Saves the record into key-value store.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} options.key - Key of the record
     * @param {String} options.contentType - Content type of body
     * @param {string|Buffer} options.body - Body in string or Buffer
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     * @returns {*}
     */
    putRecord: (requestPromise, options) => {
        const { baseUrl, storeId, key, body, contentType = 'text/plain; charset=utf-8', token } = options;
        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(key, 'key', 'String');
        (0, _utils.checkParamOrThrow)(contentType, 'contentType', 'String');
        (0, _utils.checkParamOrThrow)(body, 'body', 'Buffer | String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');

        const bufferForLengthCheck = Buffer.isBuffer(body) ? body : Buffer.from(body, 'utf-8');

        return (0, _utils.gzipPromise)(body).then(gzipedBody => {
            const requestOpts = {
                url: `${baseUrl}${BASE_PATH}/${storeId}/records/${key}`,
                method: 'PUT',
                body: gzipedBody,
                json: false,
                headers: {
                    'Content-Type': contentType,
                    'Content-Encoding': 'gzip'
                },
                qs: { token }
            };

            // Uploading via our servers:
            if (bufferForLengthCheck.byteLength < SIGNED_URL_UPLOAD_MIN_BYTESIZE) return requestPromise(requestOpts);

            // ... or via signed url directly to S3:
            return requestPromise({
                url: `${baseUrl}${BASE_PATH}/${storeId}/records/${key}/direct-upload-url`,
                method: 'GET',
                json: true,
                headers: {
                    'Content-Type': contentType
                },
                qs: { token }
            }).then(response => {
                const signedUrl = response.data.signedUrl;
                const s3RequestOpts = Object.assign({}, requestOpts, { url: signedUrl, qs: null });

                return requestPromise(s3RequestOpts);
            });
        });
    },

    /**
     * Deletes given record.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} options.key - Key of the record
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     */
    deleteRecord: (requestPromise, options) => {
        const { baseUrl, storeId, key, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(key, 'key', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${storeId}/records/${key}`,
            json: true,
            method: 'DELETE',
            qs: { token }
        });
    },

    /**
     * Returns an array containing objects representing keys in given store.
     *
     * You can paginated using exclusiveStartKey and limit parameters.
     *
     * @memberof ApifyClient.keyValueStores
     * @instance
     * @param {Object} options
     * @param {String} options.storeId - Unique store ID
     * @param {String} [options.exclusiveStartKey] - All keys up to this one (including) are skipped from the result.
     * @param {Number} [options.limit] - Number of keys to be returned. Maximum value is 1000
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~store-name" format for storeId.
     * @param callback
     * @returns {PaginationList}
     */
    listKeys: (requestPromise, options) => {
        const { baseUrl, storeId, exclusiveStartKey, limit, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(storeId, 'storeId', 'String');
        (0, _utils.checkParamOrThrow)(exclusiveStartKey, 'exclusiveStartKey', 'Maybe String');
        (0, _utils.checkParamOrThrow)(limit, 'limit', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(token, 'token', 'Maybe String');

        const query = {};
        if (token) query.token = token;
        if (exclusiveStartKey) query.exclusiveStartKey = exclusiveStartKey;
        if (limit) query.limit = limit;

        const requestOpts = {
            url: `${baseUrl}${BASE_PATH}/${storeId}/keys`,
            json: true,
            method: 'GET',
            qs: query
        };

        return requestPromise(requestOpts).then(_utils.pluckData).then(_utils.parseDateFields);
    }
};