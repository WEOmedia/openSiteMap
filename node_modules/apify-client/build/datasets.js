'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SIGNED_URL_UPLOAD_MIN_BYTESIZE = exports.BASE_PATH = undefined;
exports.parseDatasetItemsResponse = parseDatasetItemsResponse;
exports.getDatasetItems = getDatasetItems;

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _exponential_backoff = require('apify-shared/exponential_backoff');

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line import/no-duplicates


/**
 * Datasets
 * @memberOf ApifyClient
 * @description
 * ### Basic usage
 * ```javascript
 * const ApifyClient = require('apify-client');
 *
 * const apifyClient = new ApifyClient({
 *        userId: 'RWnGtczasdwP63Mak',
 *        token: 'f5J7XsdaKDyRywwuGGo9',
 * });
 * const datasets = apifyClient.datasets;
 *
 * // Get dataset with name 'my-dataset' and set it as default
 * // to be used in following commands.
 * const dataset = await datasets.getOrCreateDataset({
 *     datasetName: 'my-dataset',
 * });
 * apifyClient.setOptions({ datasetId: dataset.id });
 *
 * // Save some object and array of objects to dataset.
 * await datasets.putItems({
 *      data: { foo: 'bar' }
 * });
 * await datasets.putItems({
 *      data: [{ foo: 'hotel' }, { foo: 'restaurant' }],
 * });
 *
 * // Get items from dataset and delete it.
 * const paginationList = await datasets.getItems();
 * const items = paginationList.items;
 * await datasets.deleteDataset();
 * ```
 *
 * Every method can be used as either promise or with callback. If your Node version supports await/async then you can await promise result.
 * ```javascript
 * // Awaited promise
 * try {
 *      const items = await datasets.getItems();
 *      // Do something with the items ...
 * } catch (err) {
 *      // Do something with error ...
 * }
 *
 * // Promise
 * datasets.getItems()
 * .then((paginationList) => {
 *      console.log(paginationList.items)
 *      // Do something with items ...
 * })
 * .catch((err) => {
 *      // Do something with error ...
 * });
 *
 * // Callback
 * datasets.getItems((err, paginationList) => {
 *      console.log(paginationList.items)
 *      // Do something with error or items ...
 * });
 * ```
 * @namespace datasets
 */

const BASE_PATH = exports.BASE_PATH = '/v2/datasets'; // eslint-disable-line import/no-duplicates
const SIGNED_URL_UPLOAD_MIN_BYTESIZE = exports.SIGNED_URL_UPLOAD_MIN_BYTESIZE = 1024 * 256;

exports.default = {
    /**
     * Creates dataset of given name and returns it's object. If data with given name already exists then returns it's object.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {String} options.datasetName - Custom unique name to easily identify the dataset in the future.
     * @param callback
     * @returns {Dataset}
     */
    getOrCreateDataset: (requestPromise, options) => {
        const { baseUrl, token, datasetName } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(datasetName, 'datasetName', 'String');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}`,
            json: true,
            method: 'POST',
            qs: { name: datasetName, token }
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Returns a list of datasets owned by a user.
     *
     * By default, the objects are sorted by the createdAt field in ascending order,
     * therefore you can use pagination to incrementally fetch all datasets while new ones are still being created.
     * To sort them in descending order, use `desc: true` option.
     * The endpoint supports pagination using limit and offset parameters and it will not return more than 1000 array elements.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {Number} [options.offset=0]
     *   Number of array elements that should be skipped at the start.
     * @param {Number} [options.limit=1000]
     *   Maximum number of array elements to return.
     * @param {Boolean} [options.desc]
     *   If `true` then the objects are sorted by the startedAt field in descending order.
     * @param {Boolean} [options.unnamed]
     *   If `true` then also unnamed stores will be returned. By default only named stores are returned.
     * @param callback
     * @returns {PaginationList}
     */
    listDatasets: (requestPromise, options) => {
        const { baseUrl, token, offset, limit, desc, unnamed } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(limit, 'limit', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(offset, 'offset', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(desc, 'desc', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(unnamed, 'unnamed', 'Maybe Boolean');

        const query = { token };

        if (limit) query.limit = limit;
        if (offset) query.offset = offset;
        if (desc) query.desc = 1;
        if (unnamed) query.unnamed = 1;

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}`,
            json: true,
            method: 'GET',
            qs: query
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Returns given dataset.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param {String} options.datasetId - Unique dataset ID
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~dataset-name" format for datasetId.
     * @param callback
     * @returns {Dataset}
     */
    getDataset: (requestPromise, options) => {
        const { baseUrl, datasetId, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(datasetId, 'datasetId', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'Maybe String');

        const query = {};
        if (token) query.token = token;

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${datasetId}`,
            json: true,
            method: 'GET',
            qs: query
        }).then(_utils.pluckData).then(_utils.parseDateFields).catch(_utils.catchNotFoundOrThrow);
    },

    /**
     * Updates dataset.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param options.token
     * @param {String} options.datasetId - Unique dataset ID
     * @param {Object} options.dataset
     * @param callback
     * @returns {Dataset}
     */
    updateDataset: (requestPromise, options) => {
        const { baseUrl, token, datasetId, dataset } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');
        (0, _utils.checkParamOrThrow)(datasetId, 'datasetId', 'String');
        (0, _utils.checkParamOrThrow)(dataset, 'dataset', 'Object');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${datasetId}`,
            json: true,
            method: 'PUT',
            qs: { token },
            body: _underscore2.default.omit(dataset, 'id')
        }).then(_utils.pluckData).then(_utils.parseDateFields);
    },

    /**
     * Deletes given dataset.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param {String} options.datasetId - Unique dataset ID
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~dataset-name" format for datasetId.
     * @param callback
     * @returns {*}
     */
    deleteDataset: (requestPromise, options) => {
        const { baseUrl, datasetId, token } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(datasetId, 'datasetId', 'String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');

        return requestPromise({
            url: `${baseUrl}${BASE_PATH}/${datasetId}`,
            json: true,
            method: 'DELETE',
            qs: { token }
        });
    },

    /**
     * Returns items in the dataset based on the provided parameters
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param {String} options.datasetId
     *   Unique dataset ID
     * @param {String} [options.format='json']
     *   Format of the items, possible values are: json, csv, xlsx, html, xml and rss.
     * @param {Number} [options.offset=0]
     *   Number of array elements that should be skipped at the start.
     * @param {Number} [options.limit=100000]
     *   Maximum number of array elements to return.
     * @param {Number} [options.desc]
     *   If `true` then the objects are sorted by `createdAt` in descending order.
     *   Otherwise they are sorted in ascending order.
     * @param {Array} [options.fields]
     *   An array of field names that will be included in the result. If omitted, all fields are included in the results.
     * @param {Array} [options.omit]
     *   An array of field names that will be removed from the result. If omitted, all fields are included in the results.
     * @param {String} [options.unwind]
     *   Specifies a name of the field in the result objects that will be used to unwind the resulting objects.
     *   By default, the results are returned as they are.
     * @param {Boolean} [options.disableBodyParser]
     *   If `true` then response from API will not be parsed
     * @param {Number} [options.attachment]
     *   If `true` then the response will define the `Content-Disposition: attachment` HTTP header, forcing a web
     *   browser to download the file rather than to display it. By default, this header is not present.
     * @param {String} [options.delimiter=',']
     *   A delimiter character for CSV files, only used if `format` is `csv`.
     *   You might need to URL-encode the character (e.g. use `%09` for tab or `%3B` for semicolon).
     * @param {Number} [options.bom]
     *   All responses are encoded in UTF-8 encoding. By default, the CSV files are prefixed with the UTF-8 Byte
     *   Order Mark (BOM), while JSON, JSONL, XML, HTML and RSS files are not. If you want to override this default
     *   behavior, set `bom` option to `true` to include the BOM, or set `bom` to `false` to skip it.
     * @param {String} [options.xmlRoot]
     *   Overrides the default root element name of the XML output. By default, the root element is `results`.
     * @param {String} [options.xmlRow]
     *   Overrides the default element name that wraps each page or page function result object in XML output.
     *   By default, the element name is `page` or `result`, depending on the value of the `simplified` option.
     * @param {Boolean} [options.skipHeaderRow]
     *   If set to `true` then header row in csv format is skipped.
     * @param {Boolean} [options.clean]
     *   If `true` then the function returns only non-empty items and skips hidden fields (i.e. fields starting with `#` character).
     *   Note that the `clean` parameter is a shortcut for `skipHidden: true` and `skipEmpty: true` options.
     * @param {Boolean} [options.skipHidden]
     *   If `true` then the function doesn't return hidden fields (fields starting with "#" character).
     * @param {Boolean} [options.skipEmpty]
     *   If `true` then the function doesn't return empty items.
     *   Note that in this case the returned number of items might be lower than limit parameter and pagination must be done using the `limit` value.
     * @param {Boolean} [options.simplified]
     *   If true then, the function applies the `fields: ['url','pageFunctionResult','errorInfo']` and `unwind: 'pageFunctionResult'` options.
     *   This feature is used to emulate simplified results provided by the legacy Apify Crawler product
     *   and it's not recommended to use it in new integrations.
     * @param {Boolean} [options.skipFailedPages]
     *   If true then, the all the items with errorInfo property will be skipped from the output.
     *   This feature is here to emulate functionality of API v1 used for
     *   the legacy Apify Crawler product and it's not recommended to use it in new integrations.
     * @param {String} [options.token]
     *   Your API token at apify.com. This parameter is required
     *   only when using "username~dataset-name" format for datasetId.
     * @param callback
     * @returns {PaginationList}
     */
    getItems: (requestPromise, options) => {
        const {
            baseUrl,
            datasetId,
            disableBodyParser
        } = options;

        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(datasetId, 'datasetId', 'String');
        (0, _utils.checkParamOrThrow)(disableBodyParser, 'disableBodyParser', 'Maybe Boolean');

        // Query params:
        (0, _utils.checkParamOrThrow)(options.token, 'token', 'Maybe String');
        (0, _utils.checkParamOrThrow)(options.offset, 'offset', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(options.limit, 'limit', 'Maybe Number');
        (0, _utils.checkParamOrThrow)(options.fields, 'fields', 'Maybe [String]');
        (0, _utils.checkParamOrThrow)(options.omit, 'omit', 'Maybe [String]');
        (0, _utils.checkParamOrThrow)(options.delimiter, 'delimiter', 'Maybe String');
        (0, _utils.checkParamOrThrow)(options.unwind, 'unwind', 'Maybe String');
        (0, _utils.checkParamOrThrow)(options.xmlRoot, 'xmlRoot', 'Maybe String');
        (0, _utils.checkParamOrThrow)(options.xmlRow, 'xmlRow', 'Maybe String');
        (0, _utils.checkParamOrThrow)(options.format, 'format', 'Maybe String');

        // Booleans query params:
        (0, _utils.checkParamOrThrow)(options.desc, 'desc', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.bom, 'bom', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.attachment, 'attachment', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.skipHeaderRow, 'skipHeaderRow', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.clean, 'clean', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.skipHidden, 'skipHidden', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.skipEmpty, 'skipEmpty', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.simplified, 'simplified', 'Maybe Boolean');
        (0, _utils.checkParamOrThrow)(options.skipFailedPages, 'skipFailedPages', 'Maybe Boolean');

        // Pick query params.
        const query = _underscore2.default.pick(options, 'offset', 'limit', 'delimiter', 'unwind', 'xmlRoot', 'xmlRow', 'format', 'token');

        // Add Boolean query params.
        if (options.skipHeaderRow) query.skipHeaderRow = 1;
        if (options.desc) query.desc = 1;
        if (options.attachment) query.attachment = 1;
        if (options.clean) query.clean = 1;
        if (options.skipHidden) query.skipHidden = 1;
        if (options.skipEmpty) query.skipEmpty = 1;
        if (options.simplified) query.simplified = 1;
        if (options.skipFailedPages) query.skipFailedPages = 1;
        // Bom is handled special way because its default value for certain formats (CSV) is true which means that we need to make sure
        // that falsy value is passed in a query string as a zero.
        if (options.bom) query.bom = 1;else if (options.bom === false) query.bom = 0;

        if (options.fields) query.fields = options.fields.join(',');
        if (options.omit) query.omit = options.omit.join(',');
        const requestOpts = {
            url: `${baseUrl}${BASE_PATH}/${datasetId}/items`,
            method: 'GET',
            qs: query,
            json: false,
            gzip: true,
            resolveWithFullResponse: true,
            encoding: null
        };

        return (0, _exponential_backoff.retryWithExpBackoff)({
            func: () => getDatasetItems(requestPromise, requestOpts, disableBodyParser),
            expBackoffMillis: 200,
            expBackoffMaxRepeats: 5
        });
    },

    /**
     * Saves the object or an array of objects into dataset.
     *
     * @memberof ApifyClient.datasets
     * @instance
     * @param {Object} options
     * @param {String} options.datasetId - Unique dataset ID
     * @param {Object | Array | String} options.data - Object, Array of objects or a String. String must be a valid JSON.
     *                                                 Arrays and Objects must be JSON.stringifiable.
     * @param {String} [options.token] - Your API token at apify.com. This parameter is required
     *                                   only when using "username~dataset-name" format for datasetId.
     * @param callback
     * @returns {*}
     */
    putItems: (requestPromise, options) => {
        const { baseUrl, datasetId, data, token } = options;
        (0, _utils.checkParamOrThrow)(baseUrl, 'baseUrl', 'String');
        (0, _utils.checkParamOrThrow)(datasetId, 'datasetId', 'String');
        (0, _utils.checkParamOrThrow)(data, 'data', 'Object | Array | String');
        (0, _utils.checkParamOrThrow)(token, 'token', 'String');

        const payload = typeof data === 'string' ? data : JSON.stringify(data);

        return (0, _utils.gzipPromise)(payload).then(gzipedBody => {
            const requestOpts = {
                url: `${baseUrl}${BASE_PATH}/${datasetId}/items`,
                method: 'POST',
                body: gzipedBody,
                json: false,
                headers: {
                    'Content-Type': 'application/json; charset=utf-8',
                    'Content-Encoding': 'gzip'
                },
                qs: { token }
            };

            // Uploading via our servers:
            return requestPromise(requestOpts);
        });
    }
};
function parseDatasetItemsResponse(response, disableBodyParser) {
    const contentType = response.headers['content-type'];
    const wrappedItems = (0, _utils.wrapArray)(response);
    try {
        if (!disableBodyParser) wrappedItems.items = Utils.parseBody(wrappedItems.items, contentType);
    } catch (e) {
        if (e.message.includes('Unexpected end of JSON input')) {
            // Getting invalid JSON error should be retried, because it is similar to getting 500 response code.
            throw new _exponential_backoff.RetryableError(e);
        }
        throw e;
    }
    return wrappedItems;
}

async function getDatasetItems(requestPromise, requestOpts, disableBodyParser) {
    try {
        const response = await requestPromise(requestOpts);
        return parseDatasetItemsResponse(response, disableBodyParser);
    } catch (err) {
        return (0, _utils.catchNotFoundOrThrow)(err);
    }
}