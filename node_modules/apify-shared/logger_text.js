"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _underscore = _interopRequireDefault(require("underscore"));

var _chalk = _interopRequireDefault(require("chalk"));

var _logger = _interopRequireDefault(require("./logger"));

var _log_consts = require("./log_consts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SHORTEN_LEVELS = {
  SOFT_FAIL: 'SFAIL',
  WARNING: 'WARN'
};
const LEVEL_TO_COLOR = {
  [_log_consts.LEVELS.ERROR]: 'red',
  [_log_consts.LEVELS.SOFT_FAIL]: 'red',
  [_log_consts.LEVELS.WARNING]: 'yellow',
  [_log_consts.LEVELS.INFO]: 'green',
  [_log_consts.LEVELS.DEBUG]: 'blue',
  [_log_consts.LEVELS.PERF]: 'magenta'
};

const SHORTENED_LOG_LEVELS = _log_consts.LEVEL_TO_STRING.map(level => SHORTEN_LEVELS[level] || level);

const MAX_LEVEL_LENGTH_SPACES = Math.max(...SHORTENED_LOG_LEVELS.map(l => l.length));

const getLevelIndent = level => {
  let spaces = '';

  for (let i = 0; i < MAX_LEVEL_LENGTH_SPACES - level.length; i++) spaces += ' ';

  return spaces;
};

const DEFAULT_OPTIONS = {
  skipTime: true
};

class LoggerText extends _logger.default {
  constructor(options = {}) {
    super(Object.assign({}, DEFAULT_OPTIONS, options));
  }

  _log(level, message, data, exception, opts = {}) {
    let {
      prefix,
      suffix
    } = opts;
    let maybeDate = '';

    if (!this.options.skipTime) {
      maybeDate = `${new Date().toISOString().replace('Z', '').replace('T', ' ')} `;
    }

    const errStack = exception ? this._parseException(exception) : '';
    const color = LEVEL_TO_COLOR[level];
    const levelStr = SHORTENED_LOG_LEVELS[level];
    const levelIndent = getLevelIndent(levelStr);
    const dataStr = _underscore.default.isEmpty(data) ? '' : ` ${JSON.stringify(data)}`;
    prefix = prefix ? ` ${prefix}${_log_consts.PREFIX_DELIMITER}` : '';
    suffix = suffix ? ` ${suffix}` : '';
    const line = (0, _chalk.default)`{gray ${maybeDate}}{${color} ${levelStr}}${levelIndent}{yellow ${prefix}} ${message}{gray ${dataStr}}{yellow ${suffix}}${errStack}`; // eslint-disable-line

    this._outputWithConsole(level, line);

    return line;
  }

  _parseException(exception) {
    let errStack = ''; // Parse error.type and error.details from ApifyClientError.

    const errDetails = [];
    if (exception.type) errDetails.push(`type=${exception.type}`);

    if (exception.details) {
      _underscore.default.chain(exception.details).mapObject((val, key) => errDetails.push(`${key}=${val}`));
    } // Parse error stack lines.
    // NOTE: Reason is here to support Meteor.js like errors.


    let errorLines = exception.stack || exception.reason || exception.toString();
    errorLines = errorLines.split('\n'); // Add details to a first line.

    if (errDetails.length) errorLines[0] += (0, _chalk.default)`{gray (details: ${errDetails.join(', ')})}`; // Compose it back.

    errStack = errorLines.map(line => `  ${line}`).join('\n');
    errStack = `\n${errStack}`;
    return errStack;
  }

}

exports.default = LoggerText;
module.exports = exports.default;